---
# Raylib
---
Raylib can be accessed by importing `raylib`.
; raylib is created by Ramon Santamaria and contributors.
---
## raylib
---
```
BLEND_ADDITIVE: Const[int]
# Blend textures adding colors
BLEND_ADD_COLORS: Const[int]
# Blend textures adding colors (alternative)
BLEND_ALPHA: Const[int]
# Blend textures considering alpha (default)
BLEND_ALPHA_PREMULTIPLY: Const[int]
# Blend premultiplied textures considering alpha
BLEND_CUSTOM: Const[int]
# Blend textures using custom src/dst factors (use rlSetBlendMode())
BLEND_MULTIPLIED: Const[int]
# Blend textures multiplying colors
BLEND_SUBTRACT_COLORS: Const[int]
# Blend textures subtracting colors (alternative)
CAMERA_CUSTOM: Const[int]
# Custom camera
CAMERA_FIRST_PERSON: Const[int]
# First person camera
CAMERA_FREE: Const[int]
# Free camera
CAMERA_ORBITAL: Const[int]
# Orbital camera
CAMERA_ORTHOGRAPHIC: Const[int]
# Orthographic projection
CAMERA_PERSPECTIVE: Const[int]
# Perspective projection
CAMERA_THIRD_PERSON: Const[int]
# Third person camera
CUBEMAP_LAYOUT_AUTO_DETECT: Const[int]
# Automatically detect layout type
CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE: Const[int]
# Layout is defined by a 4x3 cross with cubemap faces
CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR: Const[int]
# Layout is defined by a 3x4 cross with cubemap faces
CUBEMAP_LAYOUT_LINE_HORIZONTAL: Const[int]
# Layout is defined by an horizontal line with faces
CUBEMAP_LAYOUT_LINE_VERTICAL: Const[int]
# Layout is defined by a vertical line with faces
CUBEMAP_LAYOUT_PANORAMA: Const[int]
# Layout is defined by a panorama image (equirectangular map)
FLAG_FULLSCREEN_MODE: Const[int]
# Set to run program in fullscreen
FLAG_INTERLACED_HINT: Const[int]
# Set to try enabling interlaced video format (for V3D)
FLAG_MSAA_4X_HINT: Const[int]
# Set to try enabling MSAA 4X
FLAG_VSYNC_HINT: Const[int]
# Set to try enabling V-Sync on GPU
FLAG_WINDOW_ALWAYS_RUN: Const[int]
# Set to allow windows running while minimized
FLAG_WINDOW_HIDDEN: Const[int]
# Set to hide window
FLAG_WINDOW_HIGHDPI: Const[int]
# Set to support HighDPI
FLAG_WINDOW_MAXIMIZED: Const[int]
# Set to maximize window (expanded to monitor)
FLAG_WINDOW_MINIMIZED: Const[int]
# Set to minimize window (iconify)
FLAG_WINDOW_MOUSE_PASSTHROUGH: Const[int]
# Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
FLAG_WINDOW_RESIZABLE: Const[int]
# Set to allow resizable window
FLAG_WINDOW_TOPMOST: Const[int]
# Set to window always on top
FLAG_WINDOW_TRANSPARENT: Const[int]
# Set to allow transparent framebuffer
FLAG_WINDOW_UNDECORATED: Const[int]
# Set to disable window decoration (frame and buttons)
FLAG_WINDOW_UNFOCUSED: Const[int]
# Set to window non focused
FONT_BITMAP: Const[int]
# Bitmap font generation, no anti-aliasing
FONT_DEFAULT: Const[int]
# Default font generation, anti-aliased
FONT_SDF: Const[int]
# SDF font generation, requires external shader
GAMEPAD_AXIS_LEFT_TRIGGER: Const[int]
# Gamepad back trigger left, pressure level: [1..-1]
GAMEPAD_AXIS_LEFT_X: Const[int]
# Gamepad left stick X axis
GAMEPAD_AXIS_LEFT_Y: Const[int]
# Gamepad left stick Y axis
GAMEPAD_AXIS_RIGHT_TRIGGER: Const[int]
# Gamepad back trigger right, pressure level: [1..-1]
GAMEPAD_AXIS_RIGHT_X: Const[int]
# Gamepad right stick X axis
GAMEPAD_AXIS_RIGHT_Y: Const[int]
# Gamepad right stick Y axis
GAMEPAD_BUTTON_LEFT_FACE_DOWN: Const[int]
# Gamepad left DPAD down button
GAMEPAD_BUTTON_LEFT_FACE_LEFT: Const[int]
# Gamepad left DPAD left button
GAMEPAD_BUTTON_LEFT_FACE_RIGHT: Const[int]
# Gamepad left DPAD right button
GAMEPAD_BUTTON_LEFT_FACE_UP: Const[int]
# Gamepad left DPAD up button
GAMEPAD_BUTTON_LEFT_THUMB: Const[int]
# Gamepad joystick pressed button left
GAMEPAD_BUTTON_LEFT_TRIGGER_1: Const[int]
# Gamepad top/back trigger left (first), it could be a trailing button
GAMEPAD_BUTTON_LEFT_TRIGGER_2: Const[int]
# Gamepad top/back trigger left (second), it could be a trailing button
GAMEPAD_BUTTON_MIDDLE: Const[int]
# Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
GAMEPAD_BUTTON_MIDDLE_LEFT: Const[int]
# Gamepad center buttons, left one (i.e. PS3: Select)
GAMEPAD_BUTTON_MIDDLE_RIGHT: Const[int]
# Gamepad center buttons, right one (i.e. PS3: Start)
GAMEPAD_BUTTON_RIGHT_FACE_DOWN: Const[int]
# Gamepad right button down (i.e. PS3: Cross, Xbox: A)
GAMEPAD_BUTTON_RIGHT_FACE_LEFT: Const[int]
# Gamepad right button left (i.e. PS3: Circle, Xbox: B)
GAMEPAD_BUTTON_RIGHT_FACE_RIGHT: Const[int]
# Gamepad right button right (i.e. PS3: Square, Xbox: X)
GAMEPAD_BUTTON_RIGHT_FACE_UP: Const[int]
# Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
GAMEPAD_BUTTON_RIGHT_THUMB: Const[int]
# Gamepad joystick pressed button right
GAMEPAD_BUTTON_RIGHT_TRIGGER_1: Const[int]
# Gamepad top/back trigger right (one), it could be a trailing button
GAMEPAD_BUTTON_RIGHT_TRIGGER_2: Const[int]
# Gamepad top/back trigger right (second), it could be a trailing button
GAMEPAD_BUTTON_UNKNOWN: Const[int]
# Unknown button, just for error checking
GESTURE_DOUBLETAP: Const[int]
# Double tap gesture
GESTURE_DRAG: Const[int]
# Drag gesture
GESTURE_HOLD: Const[int]
# Hold gesture
GESTURE_NONE: Const[int]
# No gesture
GESTURE_PINCH_IN: Const[int]
# Pinch in gesture
GESTURE_PINCH_OUT: Const[int]
# Pinch out gesture
GESTURE_SWIPE_DOWN: Const[int]
# Swipe down gesture
GESTURE_SWIPE_LEFT: Const[int]
# Swipe left gesture
GESTURE_SWIPE_RIGHT: Const[int]
# Swipe right gesture
GESTURE_SWIPE_UP: Const[int]
# Swipe up gesture
GESTURE_TAP: Const[int]
# Tap gesture
KEY_A: Const[int]
# Key: A | a
KEY_APOSTROPHE: Const[int]
# Key: '
KEY_B: Const[int]
# Key: B | b
KEY_BACK: Const[int]
# Key: Android back button
KEY_BACKSLASH: Const[int]
# Key: '\'
KEY_BACKSPACE: Const[int]
# Key: Backspace
KEY_C: Const[int]
# Key: C | c
KEY_CAPS_LOCK: Const[int]
# Key: Caps lock
KEY_COMMA: Const[int]
# Key: ,
KEY_D: Const[int]
# Key: D | d
KEY_DELETE: Const[int]
# Key: Del
KEY_DOWN: Const[int]
# Key: Cursor down
KEY_E: Const[int]
# Key: E | e
KEY_EIGHT: Const[int]
# Key: 8
KEY_END: Const[int]
# Key: End
KEY_ENTER: Const[int]
# Key: Enter
KEY_EQUAL: Const[int]
# Key: =
KEY_ESCAPE: Const[int]
# Key: Esc
KEY_F: Const[int]
# Key: F | f
KEY_F1: Const[int]
# Key: F1
KEY_F10: Const[int]
# Key: F10
KEY_F11: Const[int]
# Key: F11
KEY_F12: Const[int]
# Key: F12
KEY_F2: Const[int]
# Key: F2
KEY_F3: Const[int]
# Key: F3
KEY_F4: Const[int]
# Key: F4
KEY_F5: Const[int]
# Key: F5
KEY_F6: Const[int]
# Key: F6
KEY_F7: Const[int]
# Key: F7
KEY_F8: Const[int]
# Key: F8
KEY_F9: Const[int]
# Key: F9
KEY_FIVE: Const[int]
# Key: 5
KEY_FOUR: Const[int]
# Key: 4
KEY_G: Const[int]
# Key: G | g
KEY_GRAVE: Const[int]
# Key: `
KEY_H: Const[int]
# Key: H | h
KEY_HOME: Const[int]
# Key: Home
KEY_I: Const[int]
# Key: I | i
KEY_INSERT: Const[int]
# Key: Ins
KEY_J: Const[int]
# Key: J | j
KEY_K: Const[int]
# Key: K | k
KEY_KB_MENU: Const[int]
# Key: KB menu
KEY_KP_0: Const[int]
# Key: Keypad 0
KEY_KP_1: Const[int]
# Key: Keypad 1
KEY_KP_2: Const[int]
# Key: Keypad 2
KEY_KP_3: Const[int]
# Key: Keypad 3
KEY_KP_4: Const[int]
# Key: Keypad 4
KEY_KP_5: Const[int]
# Key: Keypad 5
KEY_KP_6: Const[int]
# Key: Keypad 6
KEY_KP_7: Const[int]
# Key: Keypad 7
KEY_KP_8: Const[int]
# Key: Keypad 8
KEY_KP_9: Const[int]
# Key: Keypad 9
KEY_KP_ADD: Const[int]
# Key: Keypad +
KEY_KP_DECIMAL: Const[int]
# Key: Keypad .
KEY_KP_DIVIDE: Const[int]
# Key: Keypad /
KEY_KP_ENTER: Const[int]
# Key: Keypad Enter
KEY_KP_EQUAL: Const[int]
# Key: Keypad =
KEY_KP_MULTIPLY: Const[int]
# Key: Keypad *
KEY_KP_SUBTRACT: Const[int]
# Key: Keypad -
KEY_L: Const[int]
# Key: L | l
KEY_LEFT: Const[int]
# Key: Cursor left
KEY_LEFT_ALT: Const[int]
# Key: Alt left
KEY_LEFT_BRACKET: Const[int]
# Key: [
KEY_LEFT_CONTROL: Const[int]
# Key: Control left
KEY_LEFT_SHIFT: Const[int]
# Key: Shift left
KEY_LEFT_SUPER: Const[int]
# Key: Super left
KEY_M: Const[int]
# Key: M | m
KEY_MENU: Const[int]
# Key: Android menu button
KEY_MINUS: Const[int]
# Key: -
KEY_N: Const[int]
# Key: N | n
KEY_NINE: Const[int]
# Key: 9
KEY_NULL: Const[int]
# Key: NULL, used for no key pressed
KEY_NUM_LOCK: Const[int]
# Key: Num lock
KEY_O: Const[int]
# Key: O | o
KEY_ONE: Const[int]
# Key: 1
KEY_P: Const[int]
# Key: P | p
KEY_PAGE_DOWN: Const[int]
# Key: Page down
KEY_PAGE_UP: Const[int]
# Key: Page up
KEY_PAUSE: Const[int]
# Key: Pause
KEY_PERIOD: Const[int]
# Key: .
KEY_PRINT_SCREEN: Const[int]
# Key: Print screen
KEY_Q: Const[int]
# Key: Q | q
KEY_R: Const[int]
# Key: R | r
KEY_RIGHT: Const[int]
# Key: Cursor right
KEY_RIGHT_ALT: Const[int]
# Key: Alt right
KEY_RIGHT_BRACKET: Const[int]
# Key: ]
KEY_RIGHT_CONTROL: Const[int]
# Key: Control right
KEY_RIGHT_SHIFT: Const[int]
# Key: Shift right
KEY_RIGHT_SUPER: Const[int]
# Key: Super right
KEY_S: Const[int]
# Key: S | s
KEY_SCROLL_LOCK: Const[int]
# Key: Scroll down
KEY_SEMICOLON: Const[int]
# Key: ;
KEY_SEVEN: Const[int]
# Key: 7
KEY_SIX: Const[int]
# Key: 6
KEY_SLASH: Const[int]
# Key: /
KEY_SPACE: Const[int]
# Key: Space
KEY_T: Const[int]
# Key: T | t
KEY_TAB: Const[int]
# Key: Tab
KEY_THREE: Const[int]
# Key: 3
KEY_TWO: Const[int]
# Key: 2
KEY_U: Const[int]
# Key: U | u
KEY_UP: Const[int]
# Key: Cursor up
KEY_V: Const[int]
# Key: V | v
KEY_VOLUME_DOWN: Const[int]
# Key: Android volume down button
KEY_VOLUME_UP: Const[int]
# Key: Android volume up button
KEY_W: Const[int]
# Key: W | w
KEY_X: Const[int]
# Key: X | x
KEY_Y: Const[int]
# Key: Y | y
KEY_Z: Const[int]
# Key: Z | z
KEY_ZERO: Const[int]
# Key: 0
LOG_ALL: Const[int]
# Display all logs
LOG_DEBUG: Const[int]
# Debug logging, used for internal debugging, it should be disabled on release builds
LOG_ERROR: Const[int]
# Error logging, used on unrecoverable failures
LOG_FATAL: Const[int]
# Fatal logging, used to abort program: exit(EXIT_FAILURE)
LOG_INFO: Const[int]
# Info logging, used for program execution info
LOG_NONE: Const[int]
# Disable logging
LOG_TRACE: Const[int]
# Trace logging, intended for internal use only
LOG_WARNING: Const[int]
# Warning logging, used on recoverable failures
MATERIAL_MAP_ALBEDO: Const[int]
# Albedo material (same as: MATERIAL_MAP_DIFFUSE)
MATERIAL_MAP_BRDF: Const[int]
# Brdf material
MATERIAL_MAP_CUBEMAP: Const[int]
# Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_EMISSION: Const[int]
# Emission material
MATERIAL_MAP_HEIGHT: Const[int]
# Heightmap material
MATERIAL_MAP_IRRADIANCE: Const[int]
# Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_METALNESS: Const[int]
# Metalness material (same as: MATERIAL_MAP_SPECULAR)
MATERIAL_MAP_NORMAL: Const[int]
# Normal material
MATERIAL_MAP_OCCLUSION: Const[int]
# Ambient occlusion material
MATERIAL_MAP_PREFILTER: Const[int]
# Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
MATERIAL_MAP_ROUGHNESS: Const[int]
# Roughness material
MOUSE_BUTTON_BACK: Const[int]
# Mouse button back (advanced mouse device)
MOUSE_BUTTON_EXTRA: Const[int]
# Mouse button extra (advanced mouse device)
MOUSE_BUTTON_FORWARD: Const[int]
# Mouse button fordward (advanced mouse device)
MOUSE_BUTTON_LEFT: Const[int]
# Mouse button left
MOUSE_BUTTON_MIDDLE: Const[int]
# Mouse button middle (pressed wheel)
MOUSE_BUTTON_RIGHT: Const[int]
# Mouse button right
MOUSE_BUTTON_SIDE: Const[int]
# Mouse button side (advanced mouse device)
MOUSE_CURSOR_ARROW: Const[int]
# Arrow shape
MOUSE_CURSOR_CROSSHAIR: Const[int]
# Cross shape
MOUSE_CURSOR_DEFAULT: Const[int]
# Default pointer shape
MOUSE_CURSOR_IBEAM: Const[int]
# Text writing cursor shape
MOUSE_CURSOR_NOT_ALLOWED: Const[int]
# The operation-not-allowed shape
MOUSE_CURSOR_POINTING_HAND: Const[int]
# Pointing hand cursor
MOUSE_CURSOR_RESIZE_ALL: Const[int]
# The omni-directional resize/move cursor shape
MOUSE_CURSOR_RESIZE_EW: Const[int]
# Horizontal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NESW: Const[int]
# The top-right to bottom-left diagonal resize/move arrow shape
MOUSE_CURSOR_RESIZE_NS: Const[int]
# Vertical resize/move arrow shape
MOUSE_CURSOR_RESIZE_NWSE: Const[int]
# Top-left to bottom-right diagonal resize/move arrow shape
NPATCH_NINE_PATCH: Const[int]
# Npatch layout: 3x3 tiles
NPATCH_THREE_PATCH_HORIZONTAL: Const[int]
# Npatch layout: 3x1 tiles
NPATCH_THREE_PATCH_VERTICAL: Const[int]
# Npatch layout: 1x3 tiles
PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: Const[int]
# 2 bpp
PIXELFORMAT_COMPRESSED_DXT1_RGB: Const[int]
# 4 bpp (no alpha)
PIXELFORMAT_COMPRESSED_DXT1_RGBA: Const[int]
# 4 bpp (1 bit alpha)
PIXELFORMAT_COMPRESSED_DXT3_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_DXT5_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_ETC1_RGB: Const[int]
# 4 bpp
PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA: Const[int]
# 8 bpp
PIXELFORMAT_COMPRESSED_ETC2_RGB: Const[int]
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGB: Const[int]
# 4 bpp
PIXELFORMAT_COMPRESSED_PVRT_RGBA: Const[int]
# 4 bpp
PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: Const[int]
# 8 bit per pixel (no alpha)
PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: Const[int]
# 8*2 bpp (2 channels)
PIXELFORMAT_UNCOMPRESSED_R32: Const[int]
# 32 bpp (1 channel - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32: Const[int]
# 32*3 bpp (3 channels - float)
PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: Const[int]
# 32*4 bpp (4 channels - float)
PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: Const[int]
# 16 bpp (4 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: Const[int]
# 16 bpp (1 bit alpha)
PIXELFORMAT_UNCOMPRESSED_R5G6B5: Const[int]
# 16 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8: Const[int]
# 24 bpp
PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: Const[int]
# 32 bpp
SHADER_ATTRIB_FLOAT: Const[int]
# Shader attribute type: float
SHADER_ATTRIB_VEC2: Const[int]
# Shader attribute type: vec2 (2 float)
SHADER_ATTRIB_VEC3: Const[int]
# Shader attribute type: vec3 (3 float)
SHADER_ATTRIB_VEC4: Const[int]
# Shader attribute type: vec4 (4 float)
SHADER_LOC_COLOR_AMBIENT: Const[int]
# Shader location: vector uniform: ambient color
SHADER_LOC_COLOR_DIFFUSE: Const[int]
# Shader location: vector uniform: diffuse color
SHADER_LOC_COLOR_SPECULAR: Const[int]
# Shader location: vector uniform: specular color
SHADER_LOC_MAP_ALBEDO: Const[int]
# Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
SHADER_LOC_MAP_BRDF: Const[int]
# Shader location: sampler2d texture: brdf
SHADER_LOC_MAP_CUBEMAP: Const[int]
# Shader location: samplerCube texture: cubemap
SHADER_LOC_MAP_EMISSION: Const[int]
# Shader location: sampler2d texture: emission
SHADER_LOC_MAP_HEIGHT: Const[int]
# Shader location: sampler2d texture: height
SHADER_LOC_MAP_IRRADIANCE: Const[int]
# Shader location: samplerCube texture: irradiance
SHADER_LOC_MAP_METALNESS: Const[int]
# Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
SHADER_LOC_MAP_NORMAL: Const[int]
# Shader location: sampler2d texture: normal
SHADER_LOC_MAP_OCCLUSION: Const[int]
# Shader location: sampler2d texture: occlusion
SHADER_LOC_MAP_PREFILTER: Const[int]
# Shader location: samplerCube texture: prefilter
SHADER_LOC_MAP_ROUGHNESS: Const[int]
# Shader location: sampler2d texture: roughness
SHADER_LOC_MATRIX_MODEL: Const[int]
# Shader location: matrix uniform: model (transform)
SHADER_LOC_MATRIX_MVP: Const[int]
# Shader location: matrix uniform: model-view-projection
SHADER_LOC_MATRIX_NORMAL: Const[int]
# Shader location: matrix uniform: normal
SHADER_LOC_MATRIX_PROJECTION: Const[int]
# Shader location: matrix uniform: projection
SHADER_LOC_MATRIX_VIEW: Const[int]
# Shader location: matrix uniform: view (camera transform)
SHADER_LOC_VECTOR_VIEW: Const[int]
# Shader location: vector uniform: view
SHADER_LOC_VERTEX_COLOR: Const[int]
# Shader location: vertex attribute: color
SHADER_LOC_VERTEX_NORMAL: Const[int]
# Shader location: vertex attribute: normal
SHADER_LOC_VERTEX_POSITION: Const[int]
# Shader location: vertex attribute: position
SHADER_LOC_VERTEX_TANGENT: Const[int]
# Shader location: vertex attribute: tangent
SHADER_LOC_VERTEX_TEXCOORD01: Const[int]
# Shader location: vertex attribute: texcoord01
SHADER_LOC_VERTEX_TEXCOORD02: Const[int]
# Shader location: vertex attribute: texcoord02
SHADER_UNIFORM_FLOAT: Const[int]
# Shader uniform type: float
SHADER_UNIFORM_INT: Const[int]
# Shader uniform type: int
SHADER_UNIFORM_IVEC2: Const[int]
# Shader uniform type: ivec2 (2 int)
SHADER_UNIFORM_IVEC3: Const[int]
# Shader uniform type: ivec3 (3 int)
SHADER_UNIFORM_IVEC4: Const[int]
# Shader uniform type: ivec4 (4 int)
SHADER_UNIFORM_SAMPLER2D: Const[int]
# Shader uniform type: sampler2d
SHADER_UNIFORM_VEC2: Const[int]
# Shader uniform type: vec2 (2 float)
SHADER_UNIFORM_VEC3: Const[int]
# Shader uniform type: vec3 (3 float)
SHADER_UNIFORM_VEC4: Const[int]
# Shader uniform type: vec4 (4 float)
TEXTURE_FILTER_ANISOTROPIC_16X: Const[int]
# Anisotropic filtering 16x
TEXTURE_FILTER_ANISOTROPIC_4X: Const[int]
# Anisotropic filtering 4x
TEXTURE_FILTER_ANISOTROPIC_8X: Const[int]
# Anisotropic filtering 8x
TEXTURE_FILTER_BILINEAR: Const[int]
# Linear filtering
TEXTURE_FILTER_POINT: Const[int]
# No filter, just pixel approximation
TEXTURE_FILTER_TRILINEAR: Const[int]
# Trilinear filtering (linear with mipmaps)
TEXTURE_WRAP_CLAMP: Const[int]
# Clamps texture to edge pixel in tiled mode
TEXTURE_WRAP_MIRROR_CLAMP: Const[int]
# Mirrors and clamps to border the texture in tiled mode
TEXTURE_WRAP_MIRROR_REPEAT: Const[int]
# Mirrors and repeats the texture in tiled mode
TEXTURE_WRAP_REPEAT: Const[int]
# Repeats texture in tiled mode
class AudioStream
# AudioStream, custom audio stream
class BoneInfo
# Bone, skeletal animation bone
class BoundingBox
# BoundingBox: 
    min: Vector3
    max: Vector3
class CChar32
class CFloat2
class CFloat4
class Camera
# Camera type fallback, defaults to Camera3D: 
    position: Vector3
    target: Vector3
    up: Vector3
    fovy: float
    projection: libs.c.CInt
class Camera2D
# Camera2D, defines position/orientation in 2d space: 
    offset: Vector2
    target: Vector2
    rotation: float
    zoom: float
class Camera3D
# Camera, defines position/orientation in 3d space: 
    position: Vector3
    target: Vector3
    up: Vector3
    fovy: float
    projection: libs.c.CInt
class Color
# Color, 4 components, R8G8B8A8 (32bit): 
    r: libs.c.CUChar
    g: libs.c.CUChar
    b: libs.c.CUChar
    a: libs.c.CUChar
class DTMatrix2
class FilePathList
# File path list
class Font
# Font, font texture and GlyphInfo array data: 
    baseSize: libs.c.CInt
    glyphCount: libs.c.CInt
    glyphPadding: libs.c.CInt
    texture: Texture2D
    recs: Ptr[Rectangle]
    glyphs: Ptr[GlyphInfo]
class GlyphInfo
# GlyphInfo, font characters glyphs info: 
    value: libs.c.CInt
    offsetX: libs.c.CInt
    offsetY: libs.c.CInt
    advanceX: libs.c.CInt
    image: Image
class Image
# Image, pixel data stored in CPU memory (RAM): 
    data: libs.c.VoidPtr
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class Material
# Material, includes shader and maps
class MaterialMap
# MaterialMap: 
    texture: Texture2D
    color: Color
    value: float
class Matrix
# Matrix, 4x4 components, column major, OpenGL style, right handed: 
    m0: float
    m4: float
    m8: float
    m12: float
    m1: float
    m5: float
    m9: float
    m13: float
    m2: float
    m6: float
    m10: float
    m14: float
    m3: float
    m7: float
    m11: float
    m15: float
class Mesh
# Mesh, vertex data and vao/vbo
class Model
# Model, meshes, materials and animation data
class ModelAnimation
# ModelAnimation
class Music
# Music, audio stream, anything longer than ~10 seconds should be streamed: 
    stream: AudioStream
    frameCount: libs.c.CUInt
    looping: bool
    ctxType: libs.c.CInt
    ctxData: libs.c.VoidPtr
class NPatchInfo
# NPatchInfo, n-patch layout info: 
    source: Rectangle
    left: libs.c.CInt
    top: libs.c.CInt
    right: libs.c.CInt
    bottom: libs.c.CInt
    layout: libs.c.CInt
class Quaternion
# Quaternion, 4 components (Vector4 alias): 
    x: float
    y: float
    z: float
    w: float
class RAudioBufferPtr
class RAudioProcessorPtr
class Ray
# Ray, ray for raycasting: 
    position: Vector3
    direction: Vector3
class RayCollision
# RayCollision, ray hit information: 
    hit: bool
    distance: float
    point: Vector3
    normal: Vector3
class Rectangle
# Rectangle, 4 components: 
    x: float
    y: float
    width: float
    height: float
class RenderTexture
# RenderTexture, fbo for texture rendering: 
    id: libs.c.CUInt
    texture: Texture
    depth: Texture
class RenderTexture2D
# RenderTexture2D, same as RenderTexture: 
    id: libs.c.CUInt
    p_texture: Texture
    depth: Texture
class Shader
# Shader
class Sound
# Sound: 
    stream: AudioStream
    frameCount: libs.c.CUInt
class Texture
# Texture, tex data stored in GPU memory (VRAM): 
    id: libs.c.CUInt
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class Texture2D
# Texture2D, same as Texture: 
    id: libs.c.CUInt
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class TextureCubemap
# TextureCubemap, same as Texture: 
    id: libs.c.CUInt
    width: libs.c.CInt
    height: libs.c.CInt
    mipmaps: libs.c.CInt
    format: libs.c.CInt
class Transform
# Transform, vectex transformation data: 
    translation: Vector3
    rotation: Quaternion
    scale: Vector3
class Vector2
# Vector2, 2 components: 
    x: float
    y: float
class Vector3
# Vector3, 3 components: 
    x: float
    y: float
    z: float
class Vector4
# Vector4, 4 components: 
    x: float
    y: float
    z: float
    w: float
class VrDeviceInfo
# VrDeviceInfo, Head-Mounted-Display device parameters
class VrStereoConfig
# VrStereoConfig, VR stereo rendering configuration for simulator
class Wave
# Wave, audio wave data: 
    frameCount: libs.c.CUInt
    sampleRate: libs.c.CUInt
    sampleSize: libs.c.CUInt
    channels: libs.c.CUInt
    data: libs.c.VoidPtr
def begin_blend_mode(mode: int) -> None
# Begin blending mode (alpha, additive, multiplied, subtract, custom)
def begin_drawing() -> None
# Setup canvas (framebuffer) to start drawing
def begin_mode2_d(p_camera: Camera2D) -> None
# Begin 2D mode with custom camera (2D)
def begin_mode3_d(p_camera: Camera3D) -> None
# Begin 3D mode with custom camera (3D)
def begin_scissor_mode(x: int, y: int, width: int, height: int) -> None
# Begin scissor mode (define screen area for following drawing)
def begin_shader_mode(shader: Shader) -> None
# Begin custom shader drawing
def begin_texture_mode(target: RenderTexture2D) -> None
# Begin drawing to render texture
def begin_vr_stereo_mode(config: VrStereoConfig) -> None
# Begin stereo rendering (requires VR simulator)
def bounding_box(min: Vector3, max: Vector3) -> BoundingBox
# Factory function for: BoundingBox
def camera(position: Vector3, target: Vector3, up: Vector3, fovy: f64, projection: int) -> Camera
# Factory function for: Camera
def camera2_d(offset: Vector2, target: Vector2, rotation: f64, zoom: f64) -> Camera2D
# Factory function for: Camera2D
def camera3_d(position: Vector3, target: Vector3, up: Vector3, fovy: f64, projection: int) -> Camera3D
# Factory function for: Camera3D
def change_directory(dir: str) -> bool
# Change working directory, return true on success
def check_collision_box_sphere(box: BoundingBox, center: Vector3, radius: f64) -> bool
# Check collision between box and sphere
def check_collision_boxes(box1: BoundingBox, box2: BoundingBox) -> bool
# Check collision between two bounding boxes
def check_collision_circle_rec(center: Vector2, radius: f64, rec: Rectangle) -> bool
# Check collision between circle and rectangle
def check_collision_circles(center1: Vector2, radius1: f64, center2: Vector2, radius2: f64) -> bool
# Check collision between two circles
def check_collision_lines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: Ptr[Vector2]) -> bool
# Check the collision between two lines defined by two points each, returns collision point by reference
def check_collision_point_circle(point: Vector2, center: Vector2, radius: f64) -> bool
# Check if point is inside circle
def check_collision_point_line(point: Vector2, p1: Vector2, p2: Vector2, threshold: int) -> bool
# Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
def check_collision_point_rec(point: Vector2, rec: Rectangle) -> bool
# Check if point is inside rectangle
def check_collision_point_triangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool
# Check if point is inside a triangle
def check_collision_recs(rec1: Rectangle, rec2: Rectangle) -> bool
# Check collision between two rectangles
def check_collision_spheres(center1: Vector3, radius1: f64, center2: Vector3, radius2: f64) -> bool
# Check collision between two spheres
def clear() -> None
# Clear background with RAYWHITE colour
def clear_background(p_color: Color) -> None
# Set background color (framebuffer clear color)
def clear_window_state(flags: u32) -> None
# Clear window configuration state flags
def close_audio_device() -> None
# Close the audio device and context
def close_window() -> None
# Close window and unload OpenGL context
def codepoint_to_utf8(codepoint: int, byteSize: Ptr[libs.c.CInt]) -> str
# Encode one codepoint into UTF-8 byte array (array length returned as parameter)
def color(r: int, g: int, b: int, a: int) -> Color
# Factory function for: Color
def color_alpha(p_color: Color, alpha: f64) -> Color
# Get color with alpha applied, alpha goes from 0.0f to 1.0f
def color_alpha_blend(dst: Color, src: Color, tint: Color) -> Color
# Get src alpha-blended into dst color with tint
def color_from_hsv(hue: f64, saturation: f64, value: f64) -> Color
# Get a Color from HSV values, hue [0..360], saturation/value [0..1]
def color_from_normalized(normalized: Vector4) -> Color
# Get Color from normalized values [0..1]
def color_normalize(p_color: Color) -> Vector4
# Get Color normalized as float [0..1]
def color_to_hsv(p_color: Color) -> Vector3
# Get HSV values for a Color, hue [0..360], saturation/value [0..1]
def color_to_int(p_color: Color) -> int
# Get hexadecimal value for a Color
def compress_data(data: Const[Ptr[libs.c.CUChar]], dataSize: int, compDataSize: Ptr[libs.c.CInt]) -> Ptr[libs.c.CUChar]
# Compress data (DEFLATE algorithm), memory must be MemFree()
def decode_data_base64(data: Const[Ptr[libs.c.CUChar]], outputSize: Ptr[libs.c.CInt]) -> Ptr[libs.c.CUChar]
# Decode Base64 string data, memory must be MemFree()
def decompress_data(compData: Const[Ptr[libs.c.CUChar]], compDataSize: int, dataSize: Ptr[libs.c.CInt]) -> Ptr[libs.c.CUChar]
# Decompress data (DEFLATE algorithm), memory must be MemFree()
def directory_exists(dirPath: str) -> bool
# Check if a directory path exists
def disable_cursor() -> None
# Disables cursor (lock cursor)
def disable_event_waiting() -> None
# Disable waiting for events on EndDrawing(), automatic events polling
def draw_billboard(p_camera: Camera, p_texture: Texture2D, position: Vector3, size: f64, tint: Color) -> None
# Draw a billboard texture
def draw_billboard_pro(p_camera: Camera, p_texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f64, tint: Color) -> None
# Draw a billboard texture defined by source and rotation
def draw_billboard_rec(p_camera: Camera, p_texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) -> None
# Draw a billboard texture defined by source
def draw_bounding_box(box: BoundingBox, p_color: Color) -> None
# Draw bounding box (wires)
def draw_circle(centerX: int, centerY: int, radius: f64, p_color: Color) -> None
# Draw a color-filled circle
def draw_circle3_d(center: Vector3, radius: f64, rotationAxis: Vector3, rotationAngle: f64, p_color: Color) -> None
# Draw a circle in 3D world space
def draw_circle_gradient(centerX: int, centerY: int, radius: f64, color1: Color, color2: Color) -> None
# Draw a gradient-filled circle
def draw_circle_lines(centerX: int, centerY: int, radius: f64, p_color: Color) -> None
# Draw circle outline
def draw_circle_sector(center: Vector2, radius: f64, startAngle: f64, endAngle: f64, segments: int, p_color: Color) -> None
# Draw a piece of a circle
def draw_circle_sector_lines(center: Vector2, radius: f64, startAngle: f64, endAngle: f64, segments: int, p_color: Color) -> None
# Draw circle sector outline
def draw_circle_v(center: Vector2, radius: f64, p_color: Color) -> None
# Draw a color-filled circle (Vector version)
def draw_cube(position: Vector3, width: f64, height: f64, length: f64, p_color: Color) -> None
# Draw cube
def draw_cube_texture(p_texture: Texture2D, position: Vector3, width: f64, height: f64, length: f64, p_color: Color) -> None
# Draw cube textured
def draw_cube_texture_rec(p_texture: Texture2D, source: Rectangle, position: Vector3, width: f64, height: f64, length: f64, p_color: Color) -> None
# Draw cube with a region of a texture
def draw_cube_v(position: Vector3, size: Vector3, p_color: Color) -> None
# Draw cube (Vector version)
def draw_cube_wires(position: Vector3, width: f64, height: f64, length: f64, p_color: Color) -> None
# Draw cube wires
def draw_cube_wires_v(position: Vector3, size: Vector3, p_color: Color) -> None
# Draw cube wires (Vector version)
def draw_cylinder(position: Vector3, radiusTop: f64, radiusBottom: f64, height: f64, slices: int, p_color: Color) -> None
# Draw a cylinder/cone
def draw_cylinder_ex(startPos: Vector3, endPos: Vector3, startRadius: f64, endRadius: f64, sides: int, p_color: Color) -> None
# Draw a cylinder with base at startPos and top at endPos
def draw_cylinder_wires(position: Vector3, radiusTop: f64, radiusBottom: f64, height: f64, slices: int, p_color: Color) -> None
# Draw a cylinder/cone wires
def draw_cylinder_wires_ex(startPos: Vector3, endPos: Vector3, startRadius: f64, endRadius: f64, sides: int, p_color: Color) -> None
# Draw a cylinder wires with base at startPos and top at endPos
def draw_ellipse(centerX: int, centerY: int, radiusH: f64, radiusV: f64, p_color: Color) -> None
# Draw ellipse
def draw_ellipse_lines(centerX: int, centerY: int, radiusH: f64, radiusV: f64, p_color: Color) -> None
# Draw ellipse outline
def draw_fps(posX: int, posY: int) -> None
# Draw current FPS
def draw_grid(slices: int, spacing: f64) -> None
# Draw a grid (centered at (0, 0, 0))
def draw_line(startPosX: int, startPosY: int, endPosX: int, endPosY: int, p_color: Color) -> None
# Draw a line
def draw_line3_d(startPos: Vector3, endPos: Vector3, p_color: Color) -> None
# Draw a line in 3D world space
def draw_line_bezier(startPos: Vector2, endPos: Vector2, thick: f64, p_color: Color) -> None
# Draw a line using cubic-bezier curves in-out
def draw_line_bezier_cubic(startPos: Vector2, endPos: Vector2, startControlPos: Vector2, endControlPos: Vector2, thick: f64, p_color: Color) -> None
# Draw line using cubic bezier curves with 2 control points
def draw_line_bezier_quad(startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: f64, p_color: Color) -> None
# Draw line using quadratic bezier curves with a control point
def draw_line_ex(startPos: Vector2, endPos: Vector2, thick: f64, p_color: Color) -> None
# Draw a line defining thickness
def draw_line_strip(points: Ptr[Vector2], pointCount: int, p_color: Color) -> None
# Draw lines sequence
def draw_line_v(startPos: Vector2, endPos: Vector2, p_color: Color) -> None
# Draw a line (Vector version)
def draw_mesh(mesh: Mesh, material: Material, p_transform: Matrix) -> None
# Draw a 3d mesh with material and transform
def draw_mesh_instanced(mesh: Mesh, material: Material, transforms: Const[Ptr[Matrix]], instances: int) -> None
# Draw multiple mesh instances with material and different transforms
def draw_model(model: Model, position: Vector3, scale: f64, tint: Color) -> None
# Draw a model (with texture if set)
def draw_model_ex(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f64, scale: Vector3, tint: Color) -> None
# Draw a model with extended parameters
def draw_model_wires(model: Model, position: Vector3, scale: f64, tint: Color) -> None
# Draw a model wires (with texture if set)
def draw_model_wires_ex(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f64, scale: Vector3, tint: Color) -> None
# Draw a model wires (with texture if set) with extended parameters
def draw_pixel(posX: int, posY: int, p_color: Color) -> None
# Draw a pixel
def draw_pixel_v(position: Vector2, p_color: Color) -> None
# Draw a pixel (Vector version)
def draw_plane(centerPos: Vector3, size: Vector2, p_color: Color) -> None
# Draw a plane XZ
def draw_point3_d(position: Vector3, p_color: Color) -> None
# Draw a point in 3D space, actually a small line
def draw_poly(center: Vector2, sides: int, radius: f64, rotation: f64, p_color: Color) -> None
# Draw a regular polygon (Vector version)
def draw_poly_lines(center: Vector2, sides: int, radius: f64, rotation: f64, p_color: Color) -> None
# Draw a polygon outline of n sides
def draw_poly_lines_ex(center: Vector2, sides: int, radius: f64, rotation: f64, lineThick: f64, p_color: Color) -> None
# Draw a polygon outline of n sides with extended parameters
def draw_ray(p_ray: Ray, p_color: Color) -> None
# Draw a ray line
def draw_rectangle(posX: int, posY: int, width: int, height: int, p_color: Color) -> None
# Draw a color-filled rectangle
def draw_rectangle_gradient_ex(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color) -> None
# Draw a gradient-filled rectangle with custom vertex colors
def draw_rectangle_gradient_h(posX: int, posY: int, width: int, height: int, color1: Color, color2: Color) -> None
# Draw a horizontal-gradient-filled rectangle
def draw_rectangle_gradient_v(posX: int, posY: int, width: int, height: int, color1: Color, color2: Color) -> None
# Draw a vertical-gradient-filled rectangle
def draw_rectangle_lines(posX: int, posY: int, width: int, height: int, p_color: Color) -> None
# Draw rectangle outline
def draw_rectangle_lines_ex(rec: Rectangle, lineThick: f64, p_color: Color) -> None
# Draw rectangle outline with extended parameters
def draw_rectangle_pro(rec: Rectangle, origin: Vector2, rotation: f64, p_color: Color) -> None
# Draw a color-filled rectangle with pro parameters
def draw_rectangle_rec(rec: Rectangle, p_color: Color) -> None
# Draw a color-filled rectangle
def draw_rectangle_rounded(rec: Rectangle, roundness: f64, segments: int, p_color: Color) -> None
# Draw rectangle with rounded edges
def draw_rectangle_rounded_lines(rec: Rectangle, roundness: f64, segments: int, lineThick: f64, p_color: Color) -> None
# Draw rectangle with rounded edges outline
def draw_rectangle_v(position: Vector2, size: Vector2, p_color: Color) -> None
# Draw a color-filled rectangle (Vector version)
def draw_ring(center: Vector2, innerRadius: f64, outerRadius: f64, startAngle: f64, endAngle: f64, segments: int, p_color: Color) -> None
# Draw ring
def draw_ring_lines(center: Vector2, innerRadius: f64, outerRadius: f64, startAngle: f64, endAngle: f64, segments: int, p_color: Color) -> None
# Draw ring outline
def draw_sphere(centerPos: Vector3, radius: f64, p_color: Color) -> None
# Draw sphere
def draw_sphere_ex(centerPos: Vector3, radius: f64, rings: int, slices: int, p_color: Color) -> None
# Draw sphere with extended parameters
def draw_sphere_wires(centerPos: Vector3, radius: f64, rings: int, slices: int, p_color: Color) -> None
# Draw sphere wires
def draw_text(text: str, posX: int, posY: int, fontSize: int, p_color: Color) -> None
# Draw text (using default font)
def draw_text_codepoint(p_font: Font, codepoint: int, position: Vector2, fontSize: f64, tint: Color) -> None
# Draw one character (codepoint)
def draw_text_codepoints(p_font: Font, codepoints: Const[Ptr[libs.c.CInt]], count: int, position: Vector2, fontSize: f64, spacing: f64, tint: Color) -> None
# Draw multiple character (codepoint)
def draw_text_ex(p_font: Font, text: str, position: Vector2, fontSize: f64, spacing: f64, tint: Color) -> None
# Draw text using font and additional parameters
def draw_text_pro(p_font: Font, text: str, position: Vector2, origin: Vector2, rotation: f64, fontSize: f64, spacing: f64, tint: Color) -> None
# Draw text using Font and pro parameters (rotation)
def draw_texture(p_texture: Texture2D, posX: int, posY: int, tint: Color) -> None
# Draw a Texture2D
def draw_texture_ex(p_texture: Texture2D, position: Vector2, rotation: f64, scale: f64, tint: Color) -> None
# Draw a Texture2D with extended parameters
def draw_texture_n_patch(p_texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f64, tint: Color) -> None
# Draws a texture (or part of it) that stretches or shrinks nicely
def draw_texture_poly(p_texture: Texture2D, center: Vector2, points: Ptr[Vector2], texcoords: Ptr[Vector2], pointCount: int, tint: Color) -> None
# Draw a textured polygon
def draw_texture_pro(p_texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f64, tint: Color) -> None
# Draw a part of a texture defined by a rectangle with 'pro' parameters
def draw_texture_quad(p_texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color) -> None
# Draw texture quad with tiling and offset parameters
def draw_texture_rec(p_texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) -> None
# Draw a part of a texture defined by a rectangle
def draw_texture_tiled(p_texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f64, scale: f64, tint: Color) -> None
# Draw part of a texture (defined by a rectangle) with rotation and scale tiled into dest.
def draw_texture_v(p_texture: Texture2D, position: Vector2, tint: Color) -> None
# Draw a Texture2D with position defined as Vector2
def draw_triangle(v1: Vector2, v2: Vector2, v3: Vector2, p_color: Color) -> None
# Draw a color-filled triangle (vertex in counter-clockwise order!)
def draw_triangle3_d(v1: Vector3, v2: Vector3, v3: Vector3, p_color: Color) -> None
# Draw a color-filled triangle (vertex in counter-clockwise order!)
def draw_triangle_fan(points: Ptr[Vector2], pointCount: int, p_color: Color) -> None
# Draw a triangle fan defined by points (first vertex is the center)
def draw_triangle_lines(v1: Vector2, v2: Vector2, v3: Vector2, p_color: Color) -> None
# Draw triangle outline (vertex in counter-clockwise order!)
def draw_triangle_strip(points: Ptr[Vector2], pointCount: int, p_color: Color) -> None
# Draw a triangle strip defined by points
def draw_triangle_strip3_d(points: Ptr[Vector3], pointCount: int, p_color: Color) -> None
# Draw a triangle strip defined by points
def enable_cursor() -> None
# Enables cursor (unlock cursor)
def enable_event_waiting() -> None
# Enable waiting for events on EndDrawing(), no automatic event polling
def encode_data_base64(data: Const[Ptr[libs.c.CUChar]], dataSize: int, outputSize: Ptr[libs.c.CInt]) -> str
# Encode data to Base64 string, memory must be MemFree()
def end_blend_mode() -> None
# End blending mode (reset to default: alpha blending)
def end_drawing() -> None
# End canvas drawing and swap buffers (double buffering)
def end_mode2_d() -> None
# Ends 2D mode with custom camera
def end_mode3_d() -> None
# Ends 3D mode and returns to default 2D orthographic mode
def end_scissor_mode() -> None
# End scissor mode
def end_shader_mode() -> None
# End custom shader drawing (use default shader)
def end_texture_mode() -> None
# Ends drawing to render texture
def end_vr_stereo_mode() -> None
# End stereo rendering (requires VR simulator)
def export_data_as_code(data: str, size: u32, fileName: str) -> bool
# Export data to code (.h), returns true on success
def export_font_as_code(p_font: Font, fileName: str) -> bool
# Export font as code file, returns true on success
def export_image(p_image: Image, fileName: str) -> bool
# Export image data to file, returns true on success
def export_image_as_code(p_image: Image, fileName: str) -> bool
# Export image as code file defining an array of bytes, returns true on success
def export_mesh(mesh: Mesh, fileName: str) -> bool
# Export mesh data to file, returns true on success
def export_wave(p_wave: Wave, fileName: str) -> bool
# Export wave data to file, returns true on success
def export_wave_as_code(p_wave: Wave, fileName: str) -> bool
# Export wave sample data to code (.h), returns true on success
def fade(p_color: Color, alpha: f64) -> Color
# Get color with alpha applied, alpha goes from 0.0f to 1.0f
def file_exists(fileName: str) -> bool
# Check if file exists
def font(baseSize: int, glyphCount: int, glyphPadding: int, p_texture: Texture2D, recs: Ptr[Rectangle], glyphs: Ptr[GlyphInfo]) -> Font
# Factory function for: Font
def gen_image_cellular(width: int, height: int, tileSize: int) -> Image
# Generate image: cellular algorithm, bigger tileSize means bigger cells
def gen_image_checked(width: int, height: int, checksX: int, checksY: int, col1: Color, col2: Color) -> Image
# Generate image: checked
def gen_image_color(width: int, height: int, p_color: Color) -> Image
# Generate image: plain color
def gen_image_font_atlas(chars: Const[Ptr[GlyphInfo]], recs: Ptr[Ptr[Rectangle]], glyphCount: int, fontSize: int, padding: int, packMethod: int) -> Image
# Generate image font atlas using chars info
def gen_image_gradient_h(width: int, height: int, left: Color, right: Color) -> Image
# Generate image: horizontal gradient
def gen_image_gradient_radial(width: int, height: int, density: f64, inner: Color, outer: Color) -> Image
# Generate image: radial gradient
def gen_image_gradient_v(width: int, height: int, top: Color, bottom: Color) -> Image
# Generate image: vertical gradient
def gen_image_white_noise(width: int, height: int, factor: f64) -> Image
# Generate image: white noise
def gen_mesh_cone(radius: f64, height: f64, slices: int) -> Mesh
# Generate cone/pyramid mesh
def gen_mesh_cube(width: f64, height: f64, length: f64) -> Mesh
# Generate cuboid mesh
def gen_mesh_cubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh
# Generate cubes-based map mesh from image data
def gen_mesh_cylinder(radius: f64, height: f64, slices: int) -> Mesh
# Generate cylinder mesh
def gen_mesh_heightmap(heightmap: Image, size: Vector3) -> Mesh
# Generate heightmap mesh from image data
def gen_mesh_hemi_sphere(radius: f64, rings: int, slices: int) -> Mesh
# Generate half-sphere mesh (no bottom cap)
def gen_mesh_knot(radius: f64, size: f64, radSeg: int, sides: int) -> Mesh
# Generate trefoil knot mesh
def gen_mesh_plane(width: f64, length: f64, resX: int, resZ: int) -> Mesh
# Generate plane mesh (with subdivisions)
def gen_mesh_poly(sides: int, radius: f64) -> Mesh
# Generate polygonal mesh
def gen_mesh_sphere(radius: f64, rings: int, slices: int) -> Mesh
# Generate sphere mesh (standard sphere)
def gen_mesh_tangents(mesh: Ptr[Mesh]) -> None
# Compute mesh tangents
def gen_mesh_torus(radius: f64, size: f64, radSeg: int, sides: int) -> Mesh
# Generate torus mesh
def gen_texture_mipmaps(p_texture: Ptr[Texture2D]) -> None
# Generate GPU mipmaps for a texture
def get_application_directory() -> str
# Get the directory if the running application (uses static string)
def get_camera_matrix(p_camera: Camera) -> Matrix
# Get camera transform matrix (view matrix)
def get_camera_matrix2_d(p_camera: Camera2D) -> Matrix
# Get camera 2d transform matrix
def get_char_pressed() -> int
# Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
def get_clipboard_text() -> str
# Get clipboard text content
def get_codepoint(text: str, bytesProcessed: Ptr[libs.c.CInt]) -> int
# Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
def get_codepoint_count(text: str) -> int
# Get total number of codepoints in a UTF-8 encoded string
def get_collision_rec(rec1: Rectangle, rec2: Rectangle) -> Rectangle
# Get collision rectangle for two rectangles collision
def get_color(hexValue: u32) -> Color
# Get Color structure from hexadecimal value
def get_current_monitor() -> int
# Get current connected monitor
def get_directory_path(filePath: str) -> str
# Get full path for a given fileName with path (uses static string)
def get_file_extension(fileName: str) -> str
# Get pointer to extension for a filename string (includes dot: '.png')
def get_file_length(fileName: str) -> int
# Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
def get_file_mod_time(fileName: str) -> i64
# Get file modification time (last write time)
def get_file_name(filePath: str) -> str
# Get pointer to filename for a path string
def get_file_name_without_ext(filePath: str) -> str
# Get filename string without extension (uses static string)
def get_font_default() -> Font
# Get the default Font
def get_fps() -> int
# Get current FPS
def get_frame_time() -> f64
# Get time in seconds for last frame drawn (delta time)
def get_gamepad_axis_count(gamepad: int) -> int
# Get gamepad axis count for a gamepad
def get_gamepad_axis_movement(gamepad: int, axis: int) -> f64
# Get axis movement value for a gamepad axis
def get_gamepad_button_pressed() -> int
# Get the last gamepad button pressed
def get_gamepad_name(gamepad: int) -> str
# Get gamepad internal name id
def get_gesture_detected() -> int
# Get latest detected gesture
def get_gesture_drag_angle() -> f64
# Get gesture drag angle
def get_gesture_drag_vector() -> Vector2
# Get gesture drag vector
def get_gesture_hold_duration() -> f64
# Get gesture hold time in milliseconds
def get_gesture_pinch_angle() -> f64
# Get gesture pinch angle
def get_gesture_pinch_vector() -> Vector2
# Get gesture pinch delta
def get_glyph_atlas_rec(p_font: Font, codepoint: int) -> Rectangle
# Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
def get_glyph_index(p_font: Font, codepoint: int) -> int
# Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
def get_glyph_info(p_font: Font, codepoint: int) -> GlyphInfo
# Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
def get_image_alpha_border(p_image: Image, threshold: f64) -> Rectangle
# Get image alpha border rectangle
def get_image_color(p_image: Image, x: int, y: int) -> Color
# Get image pixel color at (x, y) position
def get_key_pressed() -> int
# Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
def get_mesh_bounding_box(mesh: Mesh) -> BoundingBox
# Compute mesh bounding box limits
def get_model_bounding_box(model: Model) -> BoundingBox
# Compute model bounding box limits (considers all meshes)
def get_monitor_count() -> int
# Get number of connected monitors
def get_monitor_height(monitor: int) -> int
# Get specified monitor height (current video mode used by monitor)
def get_monitor_name(monitor: int) -> str
# Get the human-readable, UTF-8 encoded name of the primary monitor
def get_monitor_physical_height(monitor: int) -> int
# Get specified monitor physical height in millimetres
def get_monitor_physical_width(monitor: int) -> int
# Get specified monitor physical width in millimetres
def get_monitor_position(monitor: int) -> Vector2
# Get specified monitor position
def get_monitor_refresh_rate(monitor: int) -> int
# Get specified monitor refresh rate
def get_monitor_width(monitor: int) -> int
# Get specified monitor width (current video mode used by monitor)
def get_mouse_delta() -> Vector2
# Get mouse delta between frames
def get_mouse_position() -> Vector2
# Get mouse position XY
def get_mouse_ray(mousePosition: Vector2, p_camera: Camera) -> Ray
# Get a ray trace from mouse position
def get_mouse_wheel_move() -> f64
# Get mouse wheel movement for X or Y, whichever is larger
def get_mouse_wheel_move_v() -> Vector2
# Get mouse wheel movement for both X and Y
def get_mouse_x() -> int
# Get mouse position X
def get_mouse_y() -> int
# Get mouse position Y
def get_music_time_length(p_music: Music) -> f64
# Get music time length (in seconds)
def get_music_time_played(p_music: Music) -> f64
# Get current music time played (in seconds)
def get_pixel_color(srcPtr: libs.c.VoidPtr, format: int) -> Color
# Get Color from a source pixel pointer of certain format
def get_pixel_data_size(width: int, height: int, format: int) -> int
# Get pixel data size in bytes for certain format
def get_prev_directory_path(dirPath: str) -> str
# Get previous directory path for a given path (uses static string)
def get_random_value(min: int, max: int) -> int
# Get a random value between min and max (both included)
def get_ray_collision_box(p_ray: Ray, box: BoundingBox) -> RayCollision
# Get collision info between ray and box
def get_ray_collision_mesh(p_ray: Ray, mesh: Mesh, p_transform: Matrix) -> RayCollision
# Get collision info between ray and mesh
def get_ray_collision_quad(p_ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision
# Get collision info between ray and quad
def get_ray_collision_sphere(p_ray: Ray, center: Vector3, radius: f64) -> RayCollision
# Get collision info between ray and sphere
def get_ray_collision_triangle(p_ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision
# Get collision info between ray and triangle
def get_render_height() -> int
# Get current render height (it considers HiDPI)
def get_render_width() -> int
# Get current render width (it considers HiDPI)
def get_screen_height() -> int
# Get current screen height
def get_screen_to_world2_d(position: Vector2, p_camera: Camera2D) -> Vector2
# Get the world space position for a 2d camera screen space position
def get_screen_width() -> int
# Get current screen width
def get_shader_location(shader: Shader, uniformName: str) -> int
# Get shader uniform location
def get_shader_location_attrib(shader: Shader, attribName: str) -> int
# Get shader attribute location
def get_sounds_playing() -> int
# Get number of sounds playing in the multichannel
def get_time() -> f64
# Get elapsed time in seconds since InitWindow()
def get_touch_point_count() -> int
# Get number of touch points
def get_touch_point_id(index: int) -> int
# Get touch point identifier for given index
def get_touch_position(index: int) -> Vector2
# Get touch position XY for a touch point index (relative to screen size)
def get_touch_x() -> int
# Get touch position X for touch point 0 (relative to screen size)
def get_touch_y() -> int
# Get touch position Y for touch point 0 (relative to screen size)
def get_window_handle() -> libs.c.VoidPtr
# Get native window handle
def get_window_position() -> Vector2
# Get window position XY on monitor
def get_window_scale_dpi() -> Vector2
# Get window scale DPI factor
def get_working_directory() -> str
# Get current working directory (uses static string)
def get_world_to_screen(position: Vector3, p_camera: Camera) -> Vector2
# Get the screen space position for a 3d world space position
def get_world_to_screen2_d(position: Vector2, p_camera: Camera2D) -> Vector2
# Get the screen space position for a 2d camera world space position
def get_world_to_screen_ex(position: Vector3, p_camera: Camera, width: int, height: int) -> Vector2
# Get size position for a 3d world space position
def glyph_info(value: int, offsetX: int, offsetY: int, advanceX: int, p_image: Image) -> GlyphInfo
# Factory function for: GlyphInfo
def hide_cursor() -> None
# Hides cursor
def image(data: libs.c.VoidPtr, width: int, height: int, mipmaps: int, format: int) -> Image
# Factory function for: Image
def image_alpha_clear(p_image: Ptr[Image], p_color: Color, threshold: f64) -> None
# Clear alpha channel to desired color
def image_alpha_crop(p_image: Ptr[Image], threshold: f64) -> None
# Crop image depending on alpha value
def image_alpha_mask(p_image: Ptr[Image], alphaMask: Image) -> None
# Apply alpha mask to image
def image_alpha_premultiply(p_image: Ptr[Image]) -> None
# Premultiply alpha channel
def image_clear_background(dst: Ptr[Image], p_color: Color) -> None
# Clear image background with given color
def image_color_brightness(p_image: Ptr[Image], brightness: int) -> None
# Modify image color: brightness (-255 to 255)
def image_color_contrast(p_image: Ptr[Image], contrast: f64) -> None
# Modify image color: contrast (-100 to 100)
def image_color_grayscale(p_image: Ptr[Image]) -> None
# Modify image color: grayscale
def image_color_invert(p_image: Ptr[Image]) -> None
# Modify image color: invert
def image_color_replace(p_image: Ptr[Image], p_color: Color, replace: Color) -> None
# Modify image color: replace color
def image_color_tint(p_image: Ptr[Image], p_color: Color) -> None
# Modify image color: tint
def image_copy(p_image: Image) -> Image
# Create an image duplicate (useful for transformations)
def image_crop(p_image: Ptr[Image], crop: Rectangle) -> None
# Crop an image to a defined rectangle
def image_dither(p_image: Ptr[Image], rBpp: int, gBpp: int, bBpp: int, aBpp: int) -> None
# Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
def image_draw(dst: Ptr[Image], src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color) -> None
# Draw a source image within a destination image (tint applied to source)
def image_draw_circle(dst: Ptr[Image], centerX: int, centerY: int, radius: int, p_color: Color) -> None
# Draw circle within an image
def image_draw_circle_v(dst: Ptr[Image], center: Vector2, radius: int, p_color: Color) -> None
# Draw circle within an image (Vector version)
def image_draw_line(dst: Ptr[Image], startPosX: int, startPosY: int, endPosX: int, endPosY: int, p_color: Color) -> None
# Draw line within an image
def image_draw_line_v(dst: Ptr[Image], start: Vector2, end: Vector2, p_color: Color) -> None
# Draw line within an image (Vector version)
def image_draw_pixel(dst: Ptr[Image], posX: int, posY: int, p_color: Color) -> None
# Draw pixel within an image
def image_draw_pixel_v(dst: Ptr[Image], position: Vector2, p_color: Color) -> None
# Draw pixel within an image (Vector version)
def image_draw_rectangle(dst: Ptr[Image], posX: int, posY: int, width: int, height: int, p_color: Color) -> None
# Draw rectangle within an image
def image_draw_rectangle_lines(dst: Ptr[Image], rec: Rectangle, thick: int, p_color: Color) -> None
# Draw rectangle lines within an image
def image_draw_rectangle_rec(dst: Ptr[Image], rec: Rectangle, p_color: Color) -> None
# Draw rectangle within an image
def image_draw_rectangle_v(dst: Ptr[Image], position: Vector2, size: Vector2, p_color: Color) -> None
# Draw rectangle within an image (Vector version)
def image_draw_text(dst: Ptr[Image], text: str, posX: int, posY: int, fontSize: int, p_color: Color) -> None
# Draw text (using default font) within an image (destination)
def image_draw_text_ex(dst: Ptr[Image], p_font: Font, text: str, position: Vector2, fontSize: f64, spacing: f64, tint: Color) -> None
# Draw text (custom sprite font) within an image (destination)
def image_flip_horizontal(p_image: Ptr[Image]) -> None
# Flip image horizontally
def image_flip_vertical(p_image: Ptr[Image]) -> None
# Flip image vertically
def image_format(p_image: Ptr[Image], newFormat: int) -> None
# Convert image data to desired format
def image_from_image(p_image: Image, rec: Rectangle) -> Image
# Create an image from another image piece
def image_mipmaps(p_image: Ptr[Image]) -> None
# Compute all mipmap levels for a provided image
def image_resize(p_image: Ptr[Image], newWidth: int, newHeight: int) -> None
# Resize image (Bicubic scaling algorithm)
def image_resize_canvas(p_image: Ptr[Image], newWidth: int, newHeight: int, offsetX: int, offsetY: int, fill: Color) -> None
# Resize canvas and fill with color
def image_resize_nn(p_image: Ptr[Image], newWidth: int, newHeight: int) -> None
# Resize image (Nearest-Neighbor scaling algorithm)
def image_rotate_ccw(p_image: Ptr[Image]) -> None
# Rotate image counter-clockwise 90deg
def image_rotate_cw(p_image: Ptr[Image]) -> None
# Rotate image clockwise 90deg
def image_text(text: str, fontSize: int, p_color: Color) -> Image
# Create an image from text (default font)
def image_text_ex(p_font: Font, text: str, fontSize: f64, spacing: f64, tint: Color) -> Image
# Create an image from text (custom sprite font)
def image_to_pot(p_image: Ptr[Image], fill: Color) -> None
# Convert image to POT (power-of-two)
def init_audio_device() -> None
# Initialize audio device and context
def init_window(width: int, height: int, title: str) -> None
# Initialize window and OpenGL context
def is_audio_device_ready() -> bool
# Check if audio device has been initialized successfully
def is_audio_stream_playing(stream: AudioStream) -> bool
# Check if audio stream is playing
def is_audio_stream_processed(stream: AudioStream) -> bool
# Check if any audio stream buffers requires refill
def is_cursor_hidden() -> bool
# Check if cursor is not visible
def is_cursor_on_screen() -> bool
# Check if cursor is on the screen
def is_file_dropped() -> bool
# Check if a file has been dropped into window
def is_file_extension(fileName: str, ext: str) -> bool
# Check file extension (including point: .png, .wav)
def is_gamepad_available(gamepad: int) -> bool
# Check if a gamepad is available
def is_gamepad_button_down(gamepad: int, button: int) -> bool
# Check if a gamepad button is being pressed
def is_gamepad_button_pressed(gamepad: int, button: int) -> bool
# Check if a gamepad button has been pressed once
def is_gamepad_button_released(gamepad: int, button: int) -> bool
# Check if a gamepad button has been released once
def is_gamepad_button_up(gamepad: int, button: int) -> bool
# Check if a gamepad button is NOT being pressed
def is_gesture_detected(gesture: int) -> bool
# Check if a gesture have been detected
def is_key_down(key: int) -> bool
# Check if a key is being pressed
def is_key_pressed(key: int) -> bool
# Check if a key has been pressed once
def is_key_released(key: int) -> bool
# Check if a key has been released once
def is_key_up(key: int) -> bool
# Check if a key is NOT being pressed
def is_model_animation_valid(model: Model, anim: ModelAnimation) -> bool
# Check model animation skeleton match
def is_mouse_button_down(button: int) -> bool
# Check if a mouse button is being pressed
def is_mouse_button_pressed(button: int) -> bool
# Check if a mouse button has been pressed once
def is_mouse_button_released(button: int) -> bool
# Check if a mouse button has been released once
def is_mouse_button_up(button: int) -> bool
# Check if a mouse button is NOT being pressed
def is_music_stream_playing(p_music: Music) -> bool
# Check if music is playing
def is_path_file(path: str) -> bool
# Check if a given path is a file or a directory
def is_sound_playing(p_sound: Sound) -> bool
# Check if a sound is currently playing
def is_window_focused() -> bool
# Check if window is currently focused (only PLATFORM_DESKTOP)
def is_window_fullscreen() -> bool
# Check if window is currently fullscreen
def is_window_hidden() -> bool
# Check if window is currently hidden (only PLATFORM_DESKTOP)
def is_window_maximized() -> bool
# Check if window is currently maximized (only PLATFORM_DESKTOP)
def is_window_minimized() -> bool
# Check if window is currently minimized (only PLATFORM_DESKTOP)
def is_window_ready() -> bool
# Check if window has been initialized successfully
def is_window_resized() -> bool
# Check if window has been resized last frame
def is_window_state(flag: u32) -> bool
# Check if one specific window flag is enabled
def load_audio_stream(sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream
# Load audio stream (to stream raw audio pcm data)
def load_codepoints(text: str, count: Ptr[libs.c.CInt]) -> Ptr[libs.c.CInt]
# Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
def load_directory_files(dirPath: str) -> FilePathList
# Load directory filepaths
def load_directory_files_ex(basePath: str, filter: str, scanSubdirs: bool) -> FilePathList
# Load directory filepaths with extension filtering and recursive directory scan
def load_dropped_files() -> FilePathList
# Load dropped filepaths
def load_file_data(fileName: str, bytesRead: Ptr[libs.c.CUInt]) -> Ptr[libs.c.CUChar]
# Load file data as byte array (read)
def load_file_text(fileName: str) -> str
# Load text data from file (read), returns a '\0' terminated string
def load_font(fileName: str) -> Font
# Load font from file into GPU memory (VRAM)
def load_font_data(fileData: Const[Ptr[libs.c.CUChar]], dataSize: int, fontSize: int, fontChars: Ptr[libs.c.CInt], glyphCount: int, type: int) -> Ptr[GlyphInfo]
# Load font data for further use
def load_font_ex(fileName: str, fontSize: int, fontChars: Ptr[libs.c.CInt], glyphCount: int) -> Font
# Load font from file with extended parameters, use NULL for fontChars and 0 for glyphCount to load the default character set
def load_font_from_image(p_image: Image, key: Color, firstChar: int) -> Font
# Load font from Image (XNA style)
def load_font_from_memory(fileType: str, fileData: Const[Ptr[libs.c.CUChar]], dataSize: int, fontSize: int, fontChars: Ptr[libs.c.CInt], glyphCount: int) -> Font
# Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
def load_image(fileName: str) -> Image
# Load image from file into CPU memory (RAM)
def load_image_anim(fileName: str, frames: Ptr[libs.c.CInt]) -> Image
# Load image sequence from file (frames appended to image.data)
def load_image_colors(p_image: Image) -> Ptr[Color]
# Load color data from image as a Color array (RGBA - 32bit)
def load_image_from_memory(fileType: str, fileData: Const[Ptr[libs.c.CUChar]], dataSize: int) -> Image
# Load image from memory buffer, fileType refers to extension: i.e. '.png'
def load_image_from_screen() -> Image
# Load image from screen buffer and (screenshot)
def load_image_from_texture(p_texture: Texture2D) -> Image
# Load image from GPU texture data
def load_image_palette(p_image: Image, maxPaletteSize: int, colorCount: Ptr[libs.c.CInt]) -> Ptr[Color]
# Load colors palette from image as a Color array (RGBA - 32bit)
def load_image_raw(fileName: str, width: int, height: int, format: int, headerSize: int) -> Image
# Load image from RAW file data
def load_material_default() -> Material
# Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
def load_materials(fileName: str, materialCount: Ptr[libs.c.CInt]) -> Ptr[Material]
# Load materials from model file
def load_model(fileName: str) -> Model
# Load model from files (meshes and materials)
def load_model_animations(fileName: str, animCount: Ptr[libs.c.CUInt]) -> Ptr[ModelAnimation]
# Load model animations from file
def load_model_from_mesh(mesh: Mesh) -> Model
# Load model from generated mesh (default material)
def load_music_stream(fileName: str) -> Music
# Load music stream from file
def load_music_stream_from_memory(fileType: str, data: Const[Ptr[libs.c.CUChar]], dataSize: int) -> Music
# Load music stream from data
def load_render_texture(width: int, height: int) -> RenderTexture2D
# Load texture for rendering (framebuffer)
def load_shader(vsFileName: str, fsFileName: str) -> Shader
# Load shader from files and bind default locations
def load_shader_from_memory(vsCode: str, fsCode: str) -> Shader
# Load shader from code strings and bind default locations
def load_sound(fileName: str) -> Sound
# Load sound from file
def load_sound_from_wave(p_wave: Wave) -> Sound
# Load sound from wave data
def load_texture(fileName: str) -> Texture2D
# Load texture from file into GPU memory (VRAM)
def load_texture_cubemap(p_image: Image, layout: int) -> TextureCubemap
# Load cubemap from image, multiple image cubemap layouts supported
def load_texture_from_image(p_image: Image) -> Texture2D
# Load texture from image data
def load_vr_stereo_config(device: VrDeviceInfo) -> VrStereoConfig
# Load VR stereo config for VR simulator device parameters
def load_wave(fileName: str) -> Wave
# Load wave data from file
def load_wave_from_memory(fileType: str, fileData: Const[Ptr[libs.c.CUChar]], dataSize: int) -> Wave
# Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
def load_wave_samples(p_wave: Wave) -> Ptr[libs.c.CFloat]
# Load samples data from wave as a 32bit float data array
def material_map(p_texture: Texture2D, p_color: Color, value: f64) -> MaterialMap
# Factory function for: MaterialMap
def matrix(m0: f64, m4: f64, m8: f64, m12: f64, m1: f64, m5: f64, m9: f64, m13: f64, m2: f64, m6: f64, m10: f64, m14: f64, m3: f64, m7: f64, m11: f64, m15: f64) -> Matrix
# Factory function for: Matrix
def maximize_window() -> None
# Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
def measure_text(text: str, fontSize: int) -> int
# Measure string width for default font
def measure_text_ex(p_font: Font, text: str, fontSize: f64, spacing: f64) -> Vector2
# Measure string size for Font
def mem_alloc(size: int) -> libs.c.VoidPtr
# Internal memory allocator
def mem_free(ptr: libs.c.VoidPtr) -> None
# Internal memory free
def mem_realloc(ptr: libs.c.VoidPtr, size: int) -> libs.c.VoidPtr
# Internal memory reallocator
def minimize_window() -> None
# Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
def music(stream: AudioStream, frameCount: u32, looping: bool, ctxType: int, ctxData: libs.c.VoidPtr) -> Music
# Factory function for: Music
def n_patch_info(source: Rectangle, left: int, top: int, right: int, bottom: int, layout: int) -> NPatchInfo
# Factory function for: NPatchInfo
def open_url(url: str) -> None
# Open URL with default system browser (if available)
def pause_audio_stream(stream: AudioStream) -> None
# Pause audio stream
def pause_music_stream(p_music: Music) -> None
# Pause music playing
def pause_sound(p_sound: Sound) -> None
# Pause a sound
def play_audio_stream(stream: AudioStream) -> None
# Play audio stream
def play_music_stream(p_music: Music) -> None
# Start music playing
def play_sound(p_sound: Sound) -> None
# Play a sound
def play_sound_multi(p_sound: Sound) -> None
# Play a sound (using multichannel buffer pool)
def poll_input_events() -> None
# Register all input events
def quaternion(x: f64, y: f64, z: f64, w: f64) -> Quaternion
# Factory function for: Quaternion
def ray(position: Vector3, direction: Vector3) -> Ray
# Factory function for: Ray
def ray_collision(hit: bool, distance: f64, point: Vector3, normal: Vector3) -> RayCollision
# Factory function for: RayCollision
def rectangle(x: f64, y: f64, width: f64, height: f64) -> Rectangle
# Factory function for: Rectangle
def render_texture(id: u32, p_texture: Texture, depth: Texture) -> RenderTexture
# Factory function for: RenderTexture
def render_texture2_d(id: u32, p_texture: Texture, depth: Texture) -> RenderTexture2D
# Factory function for: RenderTexture2D
def restore_window() -> None
# Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
def resume_audio_stream(stream: AudioStream) -> None
# Resume audio stream
def resume_music_stream(p_music: Music) -> None
# Resume playing paused music
def resume_sound(p_sound: Sound) -> None
# Resume a paused sound
def save_file_data(fileName: str, data: libs.c.VoidPtr, bytesToWrite: u32) -> bool
# Save data to file from byte array (write), returns true on success
def save_file_text(fileName: str, text: str) -> bool
# Save text data to file (write), string must be '\0' terminated, returns true on success
def seek_music_stream(p_music: Music, position: f64) -> None
# Seek music to a position (in seconds)
def set_audio_stream_buffer_size_default(size: int) -> None
# Default size for new audio streams
def set_audio_stream_pan(stream: AudioStream, pan: f64) -> None
# Set pan for audio stream (0.5 is centered)
def set_audio_stream_pitch(stream: AudioStream, pitch: f64) -> None
# Set pitch for audio stream (1.0 is base level)
def set_audio_stream_volume(stream: AudioStream, volume: f64) -> None
# Set volume for audio stream (1.0 is max level)
def set_camera_alt_control(keyAlt: int) -> None
# Set camera alt key to combine with mouse movement (free camera)
def set_camera_mode(p_camera: Camera, mode: int) -> None
# Set camera mode (multiple camera modes available)
def set_camera_move_controls(keyFront: int, keyBack: int, keyRight: int, keyLeft: int, keyUp: int, keyDown: int) -> None
# Set camera move controls (1st person and 3rd person cameras)
def set_camera_pan_control(keyPan: int) -> None
# Set camera pan key to combine with mouse movement (free camera)
def set_camera_smooth_zoom_control(keySmoothZoom: int) -> None
# Set camera smooth zoom key to combine with mouse (free camera)
def set_clipboard_text(text: str) -> None
# Set clipboard text content
def set_config_flags(flags: u32) -> None
# Setup init configuration flags (view FLAGS)
def set_exit_key(key: int) -> None
# Set a custom key to exit program (default is ESC)
def set_gamepad_mappings(mappings: str) -> int
# Set internal gamepad mappings (SDL_GameControllerDB)
def set_gestures_enabled(flags: u32) -> None
# Enable a set of gestures using flags
def set_master_volume(volume: f64) -> None
# Set master volume (listener)
def set_material_texture(material: Ptr[Material], mapType: int, p_texture: Texture2D) -> None
# Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
def set_model_mesh_material(model: Ptr[Model], meshId: int, materialId: int) -> None
# Set material for a mesh
def set_mouse_cursor(cursor: int) -> None
# Set mouse cursor
def set_mouse_offset(offsetX: int, offsetY: int) -> None
# Set mouse offset
def set_mouse_position(x: int, y: int) -> None
# Set mouse position XY
def set_mouse_scale(scaleX: f64, scaleY: f64) -> None
# Set mouse scaling
def set_music_pan(p_music: Music, pan: f64) -> None
# Set pan for a music (0.5 is center)
def set_music_pitch(p_music: Music, pitch: f64) -> None
# Set pitch for a music (1.0 is base level)
def set_music_volume(p_music: Music, volume: f64) -> None
# Set volume for music (1.0 is max level)
def set_pixel_color(dstPtr: libs.c.VoidPtr, p_color: Color, format: int) -> None
# Set color formatted into destination pixel pointer
def set_random_seed(seed: u32) -> None
# Set the seed for the random number generator
def set_shader_value(shader: Shader, locIndex: int, value: Const[libs.c.VoidPtr], uniformType: int) -> None
# Set shader uniform value
def set_shader_value_matrix(shader: Shader, locIndex: int, mat: Matrix) -> None
# Set shader uniform value (matrix 4x4)
def set_shader_value_texture(shader: Shader, locIndex: int, p_texture: Texture2D) -> None
# Set shader uniform value for texture (sampler2d)
def set_shader_value_v(shader: Shader, locIndex: int, value: Const[libs.c.VoidPtr], uniformType: int, count: int) -> None
# Set shader uniform value vector
def set_shapes_texture(p_texture: Texture2D, source: Rectangle) -> None
# Set texture and rectangle to be used on shapes drawing
def set_sound_pan(p_sound: Sound, pan: f64) -> None
# Set pan for a sound (0.5 is center)
def set_sound_pitch(p_sound: Sound, pitch: f64) -> None
# Set pitch for a sound (1.0 is base level)
def set_sound_volume(p_sound: Sound, volume: f64) -> None
# Set volume for a sound (1.0 is max level)
def set_target_fps(fps: int) -> None
# Set target FPS (maximum)
def set_texture_filter(p_texture: Texture2D, filter: int) -> None
# Set texture scaling filter mode
def set_texture_wrap(p_texture: Texture2D, wrap: int) -> None
# Set texture wrapping mode
def set_trace_log_level(logLevel: int) -> None
# Set the current threshold (minimum) log level
def set_window_icon(p_image: Image) -> None
# Set icon for window (only PLATFORM_DESKTOP)
def set_window_min_size(width: int, height: int) -> None
# Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
def set_window_monitor(monitor: int) -> None
# Set monitor for the current window (fullscreen mode)
def set_window_opacity(opacity: f64) -> None
# Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
def set_window_position(x: int, y: int) -> None
# Set window position on screen (only PLATFORM_DESKTOP)
def set_window_size(width: int, height: int) -> None
# Set window dimensions
def set_window_state(flags: u32) -> None
# Set window configuration state using flags (only PLATFORM_DESKTOP)
def set_window_title(title: str) -> None
# Set title for window (only PLATFORM_DESKTOP)
def show_cursor() -> None
# Shows cursor
def sound(stream: AudioStream, frameCount: u32) -> Sound
# Factory function for: Sound
def stop_audio_stream(stream: AudioStream) -> None
# Stop audio stream
def stop_music_stream(p_music: Music) -> None
# Stop music playing
def stop_sound(p_sound: Sound) -> None
# Stop playing a sound
def stop_sound_multi() -> None
# Stop any sound playing (using multichannel buffer pool)
def swap_screen_buffer() -> None
# Swap back buffer with front buffer (screen drawing)
def take_screenshot(fileName: str) -> None
# Takes a screenshot of current screen (filename extension defines format)
def text_append(text: str, append: str, position: Ptr[libs.c.CInt]) -> None
# Append text at specific position and move cursor!
def text_codepoints_to_utf8(codepoints: Const[Ptr[libs.c.CInt]], length: int) -> str
# Encode text as codepoints array into UTF-8 text string (WARNING: memory must be freed!)
def text_copy(dst: str, src: str) -> int
# Copy one string to another, returns bytes copied
def text_find_index(text: str, find: str) -> int
# Find first text occurrence within a string
def text_insert(text: str, insert: str, position: int) -> str
# Insert text in a position (WARNING: memory must be freed!)
def text_is_equal(text1: str, text2: str) -> bool
# Check if two text string are equal
def text_join(textList: Const[Ptr[Ptr[libs.c.CChar]]], count: int, delimiter: str) -> str
# Join text strings with delimiter
def text_length(text: str) -> u32
# Get text length, checks for '\0' ending
def text_replace(text: str, replace: str, by: str) -> str
# Replace text string (WARNING: memory must be freed!)
def text_split(text: str, delimiter: int, count: Ptr[libs.c.CInt]) -> Const[Ptr[Ptr[libs.c.CChar]]]
# Split text into multiple strings
def text_subtext(text: str, position: int, length: int) -> str
# Get a piece of a text string
def text_to_integer(text: str) -> int
# Get integer value from text (negative values not supported)
def text_to_lower(text: str) -> str
# Get lower case version of provided string
def text_to_pascal(text: str) -> str
# Get Pascal case notation version of provided string
def text_to_upper(text: str) -> str
# Get upper case version of provided string
def texture(id: u32, width: int, height: int, mipmaps: int, format: int) -> Texture
# Factory function for: Texture
def texture2_d(id: u32, width: int, height: int, mipmaps: int, format: int) -> Texture2D
# Factory function for: Texture2D
def texture_cubemap(id: u32, width: int, height: int, mipmaps: int, format: int) -> TextureCubemap
# Factory function for: TextureCubemap
def toggle_fullscreen() -> None
# Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
def transform(translation: Vector3, rotation: Quaternion, scale: Vector3) -> Transform
# Factory function for: Transform
def unload_audio_stream(stream: AudioStream) -> None
# Unload audio stream and free memory
def unload_codepoints(codepoints: Ptr[libs.c.CInt]) -> None
# Unload codepoints data from memory
def unload_directory_files(files: FilePathList) -> None
# Unload filepaths
def unload_dropped_files(files: FilePathList) -> None
# Unload dropped filepaths
def unload_file_data(data: Ptr[libs.c.CUChar]) -> None
# Unload file data allocated by LoadFileData()
def unload_file_text(text: str) -> None
# Unload file text data allocated by LoadFileText()
def unload_font(p_font: Font) -> None
# Unload font from GPU memory (VRAM)
def unload_font_data(chars: Ptr[GlyphInfo], glyphCount: int) -> None
# Unload font chars info data (RAM)
def unload_image(p_image: Image) -> None
# Unload image from CPU memory (RAM)
def unload_image_colors(colors: Ptr[Color]) -> None
# Unload color data loaded with LoadImageColors()
def unload_image_palette(colors: Ptr[Color]) -> None
# Unload colors palette loaded with LoadImagePalette()
def unload_material(material: Material) -> None
# Unload material from GPU memory (VRAM)
def unload_mesh(mesh: Mesh) -> None
# Unload mesh data from CPU and GPU
def unload_model(model: Model) -> None
# Unload model (including meshes) from memory (RAM and/or VRAM)
def unload_model_animation(anim: ModelAnimation) -> None
# Unload animation data
def unload_model_animations(animations: Ptr[ModelAnimation], count: u32) -> None
# Unload animation array data
def unload_model_keep_meshes(model: Model) -> None
# Unload model (but not meshes) from memory (RAM and/or VRAM)
def unload_music_stream(p_music: Music) -> None
# Unload music stream
def unload_render_texture(target: RenderTexture2D) -> None
# Unload render texture from GPU memory (VRAM)
def unload_shader(shader: Shader) -> None
# Unload shader from GPU memory (VRAM)
def unload_sound(p_sound: Sound) -> None
# Unload sound
def unload_texture(p_texture: Texture2D) -> None
# Unload texture from GPU memory (VRAM)
def unload_vr_stereo_config(config: VrStereoConfig) -> None
# Unload VR stereo config
def unload_wave(p_wave: Wave) -> None
# Unload wave data
def unload_wave_samples(samples: Ptr[libs.c.CFloat]) -> None
# Unload samples data loaded with LoadWaveSamples()
def update_audio_stream(stream: AudioStream, data: Const[libs.c.VoidPtr], frameCount: int) -> None
# Update audio stream buffers with data
def update_camera(p_camera: Ptr[Camera]) -> None
# Update camera position for selected mode
def update_mesh_buffer(mesh: Mesh, index: int, data: Const[libs.c.VoidPtr], dataSize: int, offset: int) -> None
# Update mesh vertex data in GPU for a specific buffer index
def update_model_animation(model: Model, anim: ModelAnimation, frame: int) -> None
# Update model animation pose
def update_music_stream(p_music: Music) -> None
# Updates buffers for music streaming
def update_sound(p_sound: Sound, data: Const[libs.c.VoidPtr], sampleCount: int) -> None
# Update sound buffer with new data
def update_texture(p_texture: Texture2D, pixels: Const[libs.c.VoidPtr]) -> None
# Update GPU texture with new data
def update_texture_rec(p_texture: Texture2D, rec: Rectangle, pixels: Const[libs.c.VoidPtr]) -> None
# Update GPU texture rectangle with new data
def upload_mesh(mesh: Ptr[Mesh], dynamic: bool) -> None
# Upload mesh vertex data in GPU and provide VAO/VBO ids
def vector2(x: f64, y: f64) -> Vector2
# Factory function for: Vector2
def vector3(x: f64, y: f64, z: f64) -> Vector3
# Factory function for: Vector3
def vector4(x: f64, y: f64, z: f64, w: f64) -> Vector4
# Factory function for: Vector4
def wait_time(seconds: f64) -> None
# Wait for some time (halt program execution)
def wave(frameCount: u32, sampleRate: u32, sampleSize: u32, channels: u32, data: libs.c.VoidPtr) -> Wave
# Factory function for: Wave
def wave_copy(p_wave: Wave) -> Wave
# Copy a wave to a new wave
def wave_crop(p_wave: Ptr[Wave], initSample: int, finalSample: int) -> None
# Crop a wave to defined samples range
def wave_format(p_wave: Ptr[Wave], sampleRate: int, sampleSize: int, channels: int) -> None
# Convert wave data to desired format
def window_should_close() -> bool
# Check if KEY_ESCAPE pressed or Close icon pressed
```
---
## raylib.utils
---
```
def cos_deg(x: f64) -> f64
def lerp_color(a: raylib.Color, b: raylib.Color, fraction: f64) -> raylib.Color
def pi() -> f64
# Get approximate PI value
def remap(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64
# Map x to be from 'a to b' range to 'c to d' range
def sin_deg(x: f64) -> f64
def tan_deg(x: f64) -> f64
def todeg(radians: f64) -> f64
def torad(degrees: f64) -> f64
```
---
